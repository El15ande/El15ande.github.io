<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-29T16:21:01+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">El15ande (Allen Wang)</title><subtitle>Penultimate student @ University of St Andrews</subtitle><entry><title type="html">JavaScript Variables Mysteries: Hoisting &amp;amp; Temporal Dead Zone</title><link href="http://localhost:4000/JS-Variable-Mysteries/" rel="alternate" type="text/html" title="JavaScript Variables Mysteries: Hoisting &amp; Temporal Dead Zone" /><published>2019-07-24T00:00:00+08:00</published><updated>2019-07-24T00:00:00+08:00</updated><id>http://localhost:4000/JS-Variable-Mysteries</id><content type="html" xml:base="http://localhost:4000/JS-Variable-Mysteries/">&lt;hr /&gt;

&lt;h6 id=&quot;关键词-es6-javascript变量提升-暂存死区tdz&quot;&gt;&lt;em&gt;关键词: ES6, JavaScript变量提升, 暂存死区(TDZ)&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;重启博客&quot;&gt;重启博客…&lt;/h2&gt;

&lt;p&gt;由于最近的工作接触了一些SaaS前端的问题(主要是JS和框架的开发和bug修复), 在修复了一些由于变量提升(hoisting)和变量域(scope)的bug之后, 我对JS中&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;的使用产生了疑惑: 如何确定&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;变量的作用域? / 应该如何使用变量以确保最模块化(modular)的JS代码? / 如何最大限度的避免&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;和引用&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;? 以下的内容中将分享一些我对于JS变量的理解.&lt;/p&gt;

&lt;h2 id=&quot;js常量变量基础-浅水区&quot;&gt;JS常量变量基础 (浅水区)&lt;/h2&gt;

&lt;p&gt;自ES6标准引入了函数作用域(function-scoped)变量&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;已经过去了4年. 即使ES6仍不能做到100%代替ES5(&lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;兼容问题链接&lt;/a&gt;), 但我个人认为现在新入坑的JS程序员也应该把如何使用&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;以及hoisting的基本机制做为入门的基本知识而不仅仅只使用&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;来定义变量. 当然, 单纯的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;能够保证在不稳定运行环境(比如SAFARI)的稳定性, 但随着版本的更新迭代我们更应该提升代码的安全性, 高效性和可读性, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;就可以帮助我们做到这一点.&lt;/p&gt;

&lt;p&gt;首先是一些基本的概念: JS使用的是动态类型的概念, 变量的类型由所赋的值决定. 在ES6标准中有3种变量声明方式:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;, 被&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;定义的变量本身无法修改, 可以近似看作不变的(immutable)常量, 如同C++中的&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;或者Java中的&lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt;. 但实际上&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;对象和数组的属性或元素是可以被改变的, 无法被改变的应是&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;指针指向的地址(不确定, 如有错误请指正):
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     const x = { foo: 'bar' };
     x.foo = 'baz';
     console.log(x.foo); // -&amp;gt; baz

     const y = ['foo', 'bar'];
     y[1] = 'baz';
     console.log(y); // -&amp;gt; ['foo', 'baz']
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;, 被&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;定义的变量的作用域位于&lt;u&gt;当前执行环境的域中&lt;/u&gt;, 在函数中定义的被称作函数域变量(function-scoped), 其余未使用&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;关键字定义的(或赋值给未声明变量的值)和定义于全局域的被称作全局变量(global-scoped). 所以当声明变量的时候建议至少使用&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;之一的关键字进行定义.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;, 被&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;定义的变量被称作块级作用域(block-scoped), 作用域的问题将在TDZ里讨论. 唯一需要注意的是&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;变量不会为&lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt;对象创建属性, 而全局级的&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;则会:
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     var x = 1;
     let y = 2;
     console.log(window.x); // -&amp;gt; 1
     console.log(window.y); // -&amp;gt; undefined
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;除此之外, JS和其他语言还有一个不同的地方在于变量提升: JS中变量和函数的声明(declaration)会在编译时就被放入内存中, 也就是所谓’物理层面移动到代码的最顶端’. 所以在JS中, 以下的写法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    foo = 'bar'; // Initialisation
    console.log(foo); // -&amp;gt; bar
    ...
    var foo; // Declaration
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    var foo; // Declaration hoisted at the top
    ...
    foo = 'bar'; // Initialisation
    console.log(foo) // -&amp;gt; bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;都是正确的. 需要注意的是所有的变量仍然遵守’赋值后使用’, 所以下面这种写法:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    console.log(foo); // -&amp;gt; undefined
    var foo; // Declaration hoisted at the top
    foo = 'bar' // Initialisation after it is used
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;依旧会报错. 另一个需要注意的点是:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    var foo = 'bar';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;是直接赋值(initialisation), 所以这种变量并不会被提升, 以下的写法依旧会报错:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    var x = 1; // Initialisation
    console.log(x + &quot;&amp;amp;&quot; + y) // -&amp;gt; 1&amp;amp;undefined
    var y = 2; // Initialisation that is not hoisted
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;暂存死区-tdz-深水区&quot;&gt;暂存死区 (TDZ) (深水区)&lt;/h2&gt;

&lt;p&gt;假设以下代码位于全局中:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    console.log(foo1); // -&amp;gt; undefined
    var foo1 = 'bar';

    foo2 = 'barr'
    console.log(foo2); // -&amp;gt; 'barr'
    var foo2;

    console.log(foo3); // Uncaught ReferenceError
    let foo3 = 'baz';

    console.log(foo4); // Uncaught ReferenceError
    let foo4;
    foo4 = 'bazz';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foo1&lt;/code&gt;在未被赋值前就被使用, 所以会在使用时打印出&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;(&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;变量未被赋值时的默认值), &lt;code class=&quot;highlighter-rouge&quot;&gt;foo2&lt;/code&gt;是之前提到的变量提升的一个很典型的例子.&lt;br /&gt;
但重点在于使用&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;声明的&lt;code class=&quot;highlighter-rouge&quot;&gt;foo3&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;foo4&lt;/code&gt;: 它们报了&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;错, 这说明了_&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;&lt;u&gt;变量语句在未被执行前无法被初始化&lt;/u&gt;. 更进一步的说:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    foo5 = 'foobar';
    console.log(foo5); // Uncaught ReferenceError
    let foo5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;foo5&lt;/code&gt;同样报错, 这便是&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;变量的特性: _&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;&lt;u&gt;变量不会被提升&lt;/u&gt;. 在一个作用域中声明了&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;变量时, &lt;u&gt;从作用域生效到变量声明语句&lt;/u&gt;之间的时间被称作&lt;u&gt;暂存死区(Temporal Dead Zone (TDZ))&lt;/u&gt;, 在一个变量的TDZ中使用这个变量或使用&lt;code class=&quot;highlighter-rouge&quot;&gt;typeof&lt;/code&gt;会抛出&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;, 因为该变量处在未被声明的阶段(uninitialised state):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    if(true) { //TDZ starts
        // Using typeof on an undeclared variable results in undefined
        console.log(typeof x); // -&amp;gt; undefined

        ... // TDZ continues
        console.log(foo); // Uncaught ReferenceError

        // Using typeof on variables in TDZ results in UncaughtError
        console.log(typeof foo);// Uncaught ReferenceError

        let foo = 'bar'; // Varible initialised, TDZ ends
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;TDZ的存在会让未遵守’声明-赋值-使用’流的变量抛出错误, 这也促使JS程序员们在按照正常的流程定义变量的同时保证了代码的模块化和整洁性.&lt;/p&gt;

&lt;p&gt;到这里为止, 我建议JS新手们在chrome或者编辑器里尝试一下以上的代码, 了解&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;的机制, 然后喝杯咖啡休息一下. 因为以下有关JS语言环境的内容会打乱这些最基本的认知, 很容易把自己绕糊涂, 如果你是一名老JS程序员或者你对&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;的定义更感兴趣, 请看下一部分.&lt;/p&gt;

&lt;h2 id=&quot;tdz和提升的关系-深海&quot;&gt;TDZ和提升的关系 (深海)&lt;/h2&gt;

&lt;p&gt;先从TDZ开始, 对JS了解的程序员可能会认为&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;的区别在于作用域和会不会在代码执行(execution)时被提升. 但实际上根据ES6给出的定义以及一些民间的讨论, 现在流行的说法是_&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;&lt;u&gt;变量一样会被提升, 但不会返回值而是直接扔出错误&lt;/u&gt;, 证据来源于以下的代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    let x = 'foo';
    if(true) {
        console.log(x); // Uncaught ReferenceError
        let x = 'foobar';
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行时, 内区块的&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;会被提升到内区块的顶端做为第一条语句, 提升导致了&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;处于了TDZ之中从而报错. 这同样的得到了官方文档的支持: &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-let-and-const-declarations&quot;&gt;(ES6文档13.3.1 (英文))&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; declarations define variables that are scoped to the running execution context’s LexicalEnvironment.&lt;br /&gt;
-&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;声明定义了被限制在执行环境的LexicalEnvironment中的变量&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这之中的&lt;code class=&quot;highlighter-rouge&quot;&gt;LexicalEnvironment&lt;/code&gt;代指该变量能被使用的语义环境.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated.&lt;br /&gt;
-&amp;gt; 当该变量所在的语义环境被初始化时, 该变量也被创建, 但直到语义绑定被执行时才能被访问/使用&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个定义证明了这些变量的确会在其作用域被创建时被提升, 而从创建作用域到语句执行(即语义绑定)的这一段时间即是TDZ(无法被访问).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created.&lt;br /&gt;
-&amp;gt; 如果一个变量的语义绑定有初始值, 这个初始值的赋值表达式会在语义绑定执行时被赋予对应的变量(变量值可以是函数或其他变量,所以这里使用表达式一说), 而不是在该变量被创建时赋值给它.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If a LexicalBinding in a &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; declaration does not have an Initializer the variable is assigned the value &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; when the LexicalBinding is evaluated.&lt;br /&gt;
-&amp;gt; 如果&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;变量在语义绑定时没有初始值, 那么该变量初始值为&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这些定义跟语义环境无关, 但它们定义了变量的初始化行为和默认初始值: 如果一个变量被赋值, 这个值/变量只能在这条语句后被使用(比如上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;foo1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;foo3&lt;/code&gt;), 没有赋值的变量则会被初始化为&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    if(true) {
        // TDZ
        let x; // TDZ ends
        // The above equals to `let x = undefined`

        console.log(x); // -&amp;gt; undefined
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;函数tdz-默认参数-海沟&quot;&gt;函数TDZ: 默认参数 (海沟)&lt;/h2&gt;

&lt;p&gt;TDZ在被引入之后直接被引用到了JS的许多存在域问题的地方, 其中一个例子就是函数默认参数(default parameters), 来看以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    function add(x = y, y = 0) {
        return x+y;
    }

    add(1,2) // -&amp;gt; 3

    //This equals to add(1, undefined)
    add(1) // -&amp;gt; 1

    add(undefined, 1) // Uncaught ReferenceError
    add() // Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;的值在执行时会从左到右被检验, 而&lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt;处在传参区的TDZ中(函数的传参区也是块级域), 从而导致&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;, 这本身不是错误的写法, 而是实际传参时将&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;传向&lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;时才会出现的运行错误, 同样的错误也会出现在IIFE中:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    (function(x = y, y = 0) {
        return x+y;
    }(1,2)); // -&amp;gt; 3

    (function(x = y, y = 0) {
        return x+y;
    }(undefined, 1)); // Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一方面, 类似&lt;code class=&quot;highlighter-rouge&quot;&gt;let x = x&lt;/code&gt;的语句也会产生TDZ从而报错:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    function cube(x = x) {
        return x*x*x;
    }

    cube(2); // -&amp;gt; 8
    cube(); // Uncaught ReferenceError

    //...or the IIFE version
    (function(x = x) {
        return x*x*x;
    }(2)) // -&amp;gt; 8

    (function(x = x) {
        return x*x*x;
    }()) // -&amp;gt; Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而会让大部分人迷惑的一点是: 即使是在全局作用域下的&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;变量也会导致TDZ错误. 这也是因为默认函数的作用域原因:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    let foo = 42;

    (function(x = foo, foo) {
        return x+foo;
    }(1,2)); // -&amp;gt; 3

    (function(x = foo, foo) {
        //foo is undefined is this scope;
        return x+foo;
    }(1)); // -&amp;gt; NaN

    (function(x = foo, foo) {
        return x+foo;
    }()); // Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;综上所述, 对于函数的默认参数尽量避免使用变量从而产生错误, 同时也要小心可能产生的TDZ.&lt;/p&gt;

&lt;h2 id=&quot;反思与总结&quot;&gt;反思与总结&lt;/h2&gt;
&lt;p&gt;变量的作用域和TDZ在能够帮助程序员构建更整洁的代码的同时也可能会使得代码报错, 这也使得程序员们在构建局部变量时需要考虑更全面. 回到刚开始的问题 (长求总):&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;变量的作用域和错误问题: 保证不在TDZ中使用这个变量, 遵守先声明/赋值再使用的正常流以防止&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;保证模块化: 如果保证整洁性就更注重&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;; 如果保证优化(有研究表明&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;相比&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;更慢, 出处不定请指正)和兼容性则使用&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;. 在ES6的前提下先确定变量的范围(是否需要export, 是否要多次使用).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;导读及索引:&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&quot;&gt;MDN开发指南: var&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN开发指南: let&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;MDN开发指南: hoisting&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone&quot;&gt;MDN开发指南: TDZ&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified&quot;&gt;JS Rocks blog: TDZ demystified&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://segmentfault.com/a/1190000008213835&quot;&gt;思否blog: understanding ES6 TDZ&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28140450&quot;&gt;知乎专栏: 我用了两个月的时间才理解 let&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters&quot;&gt;Note 6. ES6: default values of parameters&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/&quot;&gt;JavaScript variable lifecycle: why let is not hoisted&lt;/a&gt;&lt;/p&gt;

&lt;h6 id=&quot;el15ande-深圳&quot;&gt;&lt;em&gt;El15ande, 深圳&lt;/em&gt;&lt;/h6&gt;
&lt;hr /&gt;

&lt;h6 id=&quot;keyword-es6-javascript-hoisting-temporal-dead-zone&quot;&gt;&lt;em&gt;Keyword: ES6, JavaScript Hoisting, Temporal Dead Zone&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;long-rest-since-my-last-blog&quot;&gt;Long rest since my last blog&lt;/h2&gt;

&lt;p&gt;Recently I have worked on SaaS front-end issues (using JavaScript libraries/frameworks such as Bootstrap &amp;amp; Vue.js). After fixing a series of bugs caused by the ‘mysterious’ hoisting mechanism, I am confused with ‘What should we use when we declare different types of variables/functions?’ &amp;amp; ‘How should we avoid referencing &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;s?’ and I decide to take a research on these questions.&lt;br /&gt;
In this blog I would like to share my understanding about JavaScript variables &amp;amp; TDZ.&lt;/p&gt;

&lt;h2 id=&quot;javascript-variable-basis-easy--&quot;&gt;JavaScript variable basis (easy :) )&lt;/h2&gt;

&lt;p&gt;It has been 4 years since ES6 introduced the definition of block-scoped (&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;) &amp;amp; global/function-scoped (&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;) variables, though ES6 is &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;STILL not supported by some compilers &amp;amp; browsers&lt;/a&gt;, it is highly recommanded for JavaScript newbies to understand how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; properly and how their variables/functions are hoisted. In my opinion, using &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;s everywhere is absolutely correct (concerning unstable environments like SAFARI), but it is better to separate different types of constants/variables (or even functions) apart in order to &lt;a href=&quot;https://github.com/airbnb/javascript#variables--const-let-group&quot;&gt;improve code readability&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a simple reminder, there are 3 ways to declare Javascript variables:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const foo = 'bar'&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;This declares an ‘immutable’ constant like &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; in C++ or &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; in Java. In fact, the attributes of the &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; object can be reassigned:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     const x = { foo: 'bar' };
     x.foo = 'baz';
     console.log(x.foo); // -&amp;gt; baz
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;and the elements of the &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; array can be reassigned as well:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     const x = ['foo', 'bar'];
     x[1] = 'baz';
     console.log(x); // -&amp;gt; ['foo', 'baz']
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var foo = 'bar'&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;The scope of &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; variable depends on &lt;u&gt;its current execution context&lt;/u&gt;, which is function-scoped:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     funciton f() {
         var foo = 'bar';
         console.log(foo); // -&amp;gt; bar
     }
     console.log(foo); // -&amp;gt; Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;or global-scoped if it is declared outside any function. It is noticable that &lt;u&gt;assigning a value to an undeclared variable implicitly creates it as a global variable &lt;/u&gt;(&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#Description&quot;&gt;reference&lt;/a&gt;)_, so at least one of &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; should be used when declaraing a variable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let foo = 'bar'&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variable is block-scoped, which limited itself in its defined block:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     function f() {
         // Function scope starts
         let foo = 'bar';
         console.log(foo); // -&amp;gt; bar
         if (1) { // If-statement scope starts
             let foo = 'baz';
             console.log(foo); // -&amp;gt; baz
         } // If-statement scope ends
         console.log(foo); // -&amp;gt; bar
     } // Function scope ends
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;it is also noticable that global &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variables will not create properties for &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; object, while global &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; variables will.&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     var x = 1;
     let y = 2;
     console.log(window.x); // -&amp;gt; 1
     console.log(window.y); // -&amp;gt; undefined
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hoisting: the conceptual definition of this semantic is: &lt;u&gt;variables &amp;amp; functions declarations are physically moved to the top of Javascript code&lt;/u&gt;, so&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     foo = 'bar'; // Initialisation
     console.log(foo); // -&amp;gt; bar
     ...
     var foo; // Declaration
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;works when you run the code, because it equals to:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     var foo; // Declaration hoisted at the top
     ...
     foo = 'bar'; // Initialisation
     console.log(foo) // -&amp;gt; bar
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The hoisting mechanism confuses many people at first (including me and my friends when we studied it) as it does not follow the ‘declare-before-use’ rule in other languages. In fact, &lt;u&gt;JavaScript put all variables &amp;amp; function declarations into the memory at the compilation stage, but does not change the code sequence (initialisation sequence)&lt;/u&gt;, so using a variable before it is initialised is still invalid:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    console.log(foo); // -&amp;gt; undefined
    var foo; // Declaration hoisted at the top
    foo = 'bar' // Initialisation after it is used
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    var foo = 'bar';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is an initilisation, so this will not be hoisted, as shown in the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    var x = 1; // Initialisation
    console.log(x + &quot;&amp;amp;&quot; + y) // -&amp;gt; 1&amp;amp;undefined
    var y = 2; // Initialisation that is not hoisted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reference:&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&quot;&gt;MDN developer guide: var&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN developer guide: let&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;MDN developer guide: hoisting&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;temporal-dead-zone-still-ok--&quot;&gt;Temporal Dead Zone (still OK :| )&lt;/h2&gt;
&lt;p&gt;Consider the following code in the global scope:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    console.log(foo1); // -&amp;gt; undefined
    var foo1 = 'bar';

    foo2 = 'barr'
    console.log(foo2); // -&amp;gt; 'barr'
    var foo2;

    console.log(foo3); // Uncaught ReferenceError
    let foo3 = 'baz';

    console.log(foo4); // Uncaught ReferenceError
    let foo4;
    foo4 = 'bazz';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can simply understand the code: &lt;code class=&quot;highlighter-rouge&quot;&gt;foo1&lt;/code&gt; is used before initialisation and thus it should be &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; at the moment it is used, while &lt;code class=&quot;highlighter-rouge&quot;&gt;foo2&lt;/code&gt; is a typical example of hoisting. &lt;code class=&quot;highlighter-rouge&quot;&gt;foo3&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;foo4&lt;/code&gt; are both used before initialisation, but they throw &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;, this indicates that _&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;_&lt;u&gt;variables are not initialised until their definition is evaluated&lt;/u&gt;. Furthermore, consider &lt;code class=&quot;highlighter-rouge&quot;&gt;foo5&lt;/code&gt; below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    foo5 = 'foobar';
    console.log(foo5); // Uncaught ReferenceError
    let foo5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;this indicates that _&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;_&lt;u&gt;variables are not hoisted&lt;/u&gt;. In fact, &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variables are in Temporal Dead Zone (TDZ) &lt;u&gt;from the start of the block until the initialisation is processed&lt;/u&gt;. Variables in TDZ will always throw &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt; as it is an uninitialised state, even using &lt;code class=&quot;highlighter-rouge&quot;&gt;typeof&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    if(true) { //TDZ starts
        // Using typeof on an undeclared variable results in undefined
        console.log(typeof x); // -&amp;gt; undefined

        ... // TDZ continues
        console.log(foo); // Uncaught ReferenceError

        // Using typeof on variables in TDZ results in UncaughtError
        console.log(typeof foo);// Uncaught ReferenceError

        let foo = 'bar'; // Varible initialised, TDZ ends
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Due to the existance of TDZ, variables used before initialisation are going to throw &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;s, this motivates new JavaScript programmers to follow the ‘declare-initialise-use’ flow to create &amp;amp; use variables (which produces more modular &amp;amp; cleaner code).&lt;/p&gt;

&lt;p&gt;I would highly recommand new JavaScript programmers to type these codes in editors in order to understand how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; properly, and stop here to grab a cup of coffee because the rest contents will focus on JavaScript lexical environment. However if you are curious about the mechanism of &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;, or you have been working on JavaScript for a long time, please proceed.&lt;/p&gt;

&lt;p&gt;Reference:&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone&quot;&gt;MDN developer guide: TDZ&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;tdz-towards-hoisting-a-bit-hard--&quot;&gt;TDZ towards hoisting (a bit hard :( )&lt;/h2&gt;

&lt;p&gt;Starting from TDZ, the statement of &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variables do not hoist is acutally an over-simplified summary: &lt;u&gt;these variables hoist but throw errors when used before initialised, rather than return &lt;/u&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;_, consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    let x = 'foo';
    if(true) {
        console.log(x); // Uncaught ReferenceError
        let x = 'foobar';
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On execution, &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; inside the block is hoisted as the first statement in the block, this produces TDZ and the console statement in TDZ generates &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt; which seems reasonable. As ES6 standard explained in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-let-and-const-declarations&quot;&gt;13.3.1&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; declarations define variables that are scoped to &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-execution-contexts&quot;&gt;the running execution context&lt;/a&gt;’s &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-execution-contexts&quot;&gt;LexicalEnvironment&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;the &lt;code class=&quot;highlighter-rouge&quot;&gt;LexicalEnvironment&lt;/code&gt; represents the scope which the variables exist.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This proves that &lt;code class=&quot;highlighter-rouge&quot;&gt;const/let&lt;/code&gt; variables do hoist at the moment of their scope is created, and the duration from the initialisation of the environment to the evaluation of variables is the TDZ (referenced as ‘may not accessed in any way’).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If a LexicalBinding in a &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; declaration does not have an Initializer the variable is assigned the value &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; when the LexicalBinding is evaluated.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;These declarations are not related to TDZ but referencing the basic properties of JavaScript variables: if a variable is assigned a value, the value will be usable only after the assignment (not after created, like &lt;code class=&quot;highlighter-rouge&quot;&gt;foo1&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;foo3&lt;/code&gt; above), if a variable is not assigned any values, the default value will be &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; (after exiting TDZ, the variables work in the same way):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    if(true) {
        // TDZ
        let x; // TDZ ends
        // The above equals to `let x = undefined`

        console.log(x); // -&amp;gt; undefined
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reference:&lt;br /&gt;
&lt;a href=&quot;http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified&quot;&gt;JS Rocks blog: TDZ demystified&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://segmentfault.com/a/1190000008213835&quot;&gt;Segmentfault blog: understanding ES6 TDZ (Chinese)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;function-tdz-default-parameters-harder--&quot;&gt;Function TDZ: default parameters (harder &amp;gt;:( )&lt;/h2&gt;

&lt;p&gt;TDZ mechanism appears in a lot of scenarios, one application is the default parameters of a function. Consider this function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    function add(x = y, y = 0) {
        return x+y;
    }

    add(1,2) // -&amp;gt; 3

    //This equals to add(1, undefined)
    add(1) // -&amp;gt; 1

    add(undefined, 1) // Uncaught ReferenceError
    add() // Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default parameters &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; are evaluated from left to right at the running stage, so &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; is in TDZ when &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; is evaluated which causes a &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;. Please be aware that TDZ violations will not be reported by the compiler, but it will throw the error when &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; is passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, the similar scenatio is the IIFE version of this function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    (function(x = y, y = 0) {
        return x+y;
    }(1,2)); // -&amp;gt; 3

    (function(x = y, y = 0) {
        return x+y;
    }(undefined, 1)); // Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Furthermore, the &lt;code class=&quot;highlighter-rouge&quot;&gt;let x = x&lt;/code&gt; situation also causes the TDZ violation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    function cube(x = x) {
        return x*x*x;
    }

    cube(2); // -&amp;gt; 8
    cube(); // Uncaught ReferenceError

    //...or the IIFE version
    (function(x = x) {
        return x*x*x;
    }(2)) // -&amp;gt; 8

    (function(x = x) {
        return x*x*x;
    }()) // -&amp;gt; Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interesting scenario is, what if the default parameter is given at the outside of the scope by the &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variable? The answer is that it also causes the TDZ violation as &lt;u&gt;default parameters are evaluated in an intermediate scope&lt;/u&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    let foo = 42;

    (function(x = foo, foo) {
        return x+foo;
    }(1,2)); // -&amp;gt; 3

    (function(x = foo, foo) {
        //foo is undefined is this scope;
        return x+foo;
    }(1)); // -&amp;gt; NaN

    (function(x = foo, foo) {
        return x+foo;
    }()); // Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In conclusion, I suggest &lt;u&gt;not to bind variables as the default parameters&lt;/u&gt; and &lt;u&gt;be careful of the variable scope where TDZ might exist&lt;/u&gt;. Also, Javascript classes (&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;) will also produce TDZ, if you are interested in this topic, please proceed to &lt;a href=&quot;http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified&quot;&gt;this article&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;introspection-ah-finally&quot;&gt;Introspection (ah finally)&lt;/h2&gt;

&lt;p&gt;The variables scopes &amp;amp; TDZ mechanism can be both helpful (providing error feedback when mixing scope) and dangerous (in cases of running stage errors), this enforces us to declare the global variables and scopes with more considerations and awareness. I was mixing &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;s and &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;s before I totally understand the scopes in JavaScript, and I would like to be more considerate of the scopes in order to write more modular and cleaner code.&lt;/p&gt;

&lt;p&gt;Back to the starting questions (TLDR):&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;Avoiding &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; and errors: avoid using the variable in its TDZ, follow ‘declare-assign-use’ flow.&lt;/li&gt;
  &lt;li&gt;Making code modular: prefer &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; for clean code, prefer &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; for better performance (some says &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; costs more time than &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; to create a variable, please provide the resource if you know it :)) or compatibility. Be aware of the variable scope and choose the proper variable type under ES6 environment.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;This is a simplified translation of the Chinese version above, if you have any suggestions, questions or found any bugs/grammar mistakes about this blog, please email me and I am happy to answer (or fix this blog :) )&lt;/p&gt;

&lt;p&gt;Suggested further readings:&lt;br /&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28140450&quot;&gt;Zhihu: understand &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; in 2 months (Chinese)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters&quot;&gt;Note 6. ES6: default values of parameters&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/&quot;&gt;JavaScript variable lifecycle: why let is not hoisted&lt;/a&gt;&lt;/p&gt;

&lt;h6 id=&quot;el15ande-shenzhen&quot;&gt;&lt;em&gt;El15ande, Shenzhen&lt;/em&gt;&lt;/h6&gt;</content><author><name></name></author><summary type="html">关键词: ES6, JavaScript变量提升, 暂存死区(TDZ)</summary></entry><entry><title type="html">Software Engineering In A Nutshell: FAQ &amp;amp; Answers From Ian Sommerville</title><link href="http://localhost:4000/Software-Engineering-FAQ/" rel="alternate" type="text/html" title="Software Engineering In A Nutshell: FAQ &amp; Answers From Ian Sommerville" /><published>2019-04-09T00:00:00+08:00</published><updated>2019-04-09T00:00:00+08:00</updated><id>http://localhost:4000/Software-Engineering-FAQ</id><content type="html" xml:base="http://localhost:4000/Software-Engineering-FAQ/">&lt;hr /&gt;

&lt;h6 id=&quot;keyword-software-engineering&quot;&gt;&lt;em&gt;Keyword: Software Engineering&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;well-he-was-a-st-andrews-processor&quot;&gt;Well, he was a St Andrews processor…&lt;/h2&gt;

&lt;p&gt;I am reading ‘Software Engineering’ by Ian Sommerville, his ‘FAQs about software engineering’ table on page 20 (in my opinion) is the most elegant and enlightened summary about software engineering. In the post I will share an adapted summary of the table.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Question&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Answer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What is software?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;u&gt;Computer programs &amp;amp; associated documentation&lt;/u&gt; for a particular customer or a general market&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the attributes of good software?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;u&gt;Deliver the required functionality &amp;amp; performance&lt;/u&gt; to the user &amp;amp; &lt;u&gt;be maintainable, dependable &amp;amp; usable&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What is SE?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;An engineering discipline &lt;u&gt;concerned with all aspects of software production&lt;u&gt; from initial conception to operation &amp;amp; maintenance&lt;/u&gt;&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the fundamental SE activities?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Software specification, development, validation &amp;amp; evolution&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What is the difference between SE &amp;amp; CS?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CS focuses on theory &amp;amp; fundamentals, while SE is concerned with &lt;u&gt;practicalities of developing &amp;amp; delivering good software&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What is the difference between SE &amp;amp; system engineering?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;System engineering is concerned with all aspects of computer-based system development (including hardware, software &amp;amp; process engineering), while SE is part of it&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the key challenges facing SE?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Coping with &lt;u&gt;increasing diversity&lt;/u&gt;, demands for &lt;u&gt;reduced delivery times&lt;/u&gt; &amp;amp; &lt;u&gt;developing trustworthy software&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the costs of SE?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Roughly 60% are development costs, 40% are testing costs (custom software has higher evolution costs)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the best SE techniques &amp;amp; methods?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;u&gt;Different techniques are appropriate for different types of system&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What differences has the Internet made to SE?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Internet led to the development of massive, highly distributed, &lt;u&gt;service-based systems&lt;/u&gt; &amp;amp; supported the creation of an &lt;u&gt;'app' industry&lt;/u&gt; for mobile devices&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Reference: Ian Sommerville. 2015. Software Engineering (10th ed.). Pearson.&lt;/p&gt;

&lt;h6 id=&quot;el15ande-st-andrews&quot;&gt;&lt;em&gt;El15ande, St Andrews&lt;/em&gt;&lt;/h6&gt;
&lt;hr /&gt;

&lt;h6 id=&quot;关键词-软件工程&quot;&gt;&lt;em&gt;关键词: 软件工程&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;这本书的作者曾是我们学校的教授&quot;&gt;这本书的作者曾是我们学校的教授…&lt;/h2&gt;

&lt;p&gt;在阅读Ian Sommerville的著作《Software Engineering》一书时看到了他所汇总的‘软件工程FAQ’表格，我个人认为他对这些问题的回答十分精简和引人深思。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;问&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;答&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;如何定义‘软件’？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;面向特定顾客或市场的程序及其文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;优秀软件的特性？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;为用户提供必需的功能及性能 &amp;amp; 保持可维护性，可信度以及可使用性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;如何定义‘软件工程’？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;解决软件开发及使用过程中各个方面问题的工程学&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;最基本的‘软件工程’行为有哪些？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;软件的 &lt;u&gt;需求说明，研发，检验 和 持续完善&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘软件工程’和‘计算机科学’的区别是什么？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CS注重科学上的理论基础（深有体会），SE则注重开发及提供优秀软件的实践过程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘软件工程’和‘系统工程’的区别是什么？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘系统工程’注重整个计算机（硬件，软件，应用的实际运行）系统的设计，SE包含在‘系统工程’中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘软件工程’领域最大的挑战是什么？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;考虑递增的软件多样性和递减的开发时间，并开发可靠的软件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘软件工程’花销占比如何分配？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;60%的开发花销 - 40%的测试花销（测试大过天）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;目前最好的‘软件工程’技术是什么？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;因系统而异，不同的技术对应不同的系统&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;互联网对于‘软件工程’的改变有哪些？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1. 互联网引发了对于&lt;u&gt;面向服务的系统研发&lt;/u&gt;的热潮（分布式系统）/ 2.互联网为&lt;u&gt;移动应用研发业&lt;/u&gt;提供了基础（移动设备系统）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;书籍：Ian Sommerville. 2015. Software Engineering (10th ed.). Pearson.&lt;/p&gt;

&lt;h6 id=&quot;el15ande-圣安德鲁斯&quot;&gt;&lt;em&gt;El15ande, 圣安德鲁斯&lt;/em&gt;&lt;/h6&gt;</content><author><name></name></author><summary type="html">Keyword: Software Engineering</summary></entry><entry><title type="html">Hello Jekyll: Build Personal Webpage With GithubPage &amp;amp; Jekyll</title><link href="http://localhost:4000/Hello-Jekyll/" rel="alternate" type="text/html" title="Hello Jekyll: Build Personal Webpage With GithubPage &amp; Jekyll" /><published>2019-02-11T00:00:00+08:00</published><updated>2019-02-11T00:00:00+08:00</updated><id>http://localhost:4000/Hello-Jekyll</id><content type="html" xml:base="http://localhost:4000/Hello-Jekyll/">&lt;hr /&gt;

&lt;h6 id=&quot;keyword-web-project-deployment--githubpage--jekyll&quot;&gt;&lt;em&gt;Keyword: Web Project Deployment / GithubPage / Jekyll&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;intro-when-i-really-want-to-write-some-blogs&quot;&gt;Intro: when I really want to write some blogs…&lt;/h2&gt;

&lt;p&gt;This is my first CompSci blog &amp;amp; what I have done is just writing some markdown like taking notes on a piece of paper, the whole website is generated by Jekyll &amp;amp; hosted by GithubPage. This is really convenient for programmers (or even non-programmers) to write down their ideas, experiences (or bug complaints) in a few words, then a webpage blog, decorated with nice CSS &amp;amp; clustered in ideal structure, is already there.&lt;br /&gt;
In this blog, I will share my experience about how to build a simple blogging website, with or without programming experience &amp;amp; totally without any money costs.&lt;/p&gt;

&lt;h2 id=&quot;githubpage-free-probably-website-hosting&quot;&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;GithubPage&lt;/a&gt;: free (probably) website hosting&lt;/h2&gt;

&lt;p&gt;There is a step-by-step tutorial from youtube for non-programmers: &lt;a href=&quot;https://youtu.be/FiOgz3nKpgk&quot;&gt;Tutorial&lt;/a&gt;.&lt;br /&gt;
And the Git command cheatsheet from Github: &lt;a href=&quot;https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf&quot;&gt;Cheatsheet&lt;/a&gt;.&lt;br /&gt;
A few tips:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The branching of the repoistory is actually not that necessary to do unless you want a really clustered repository structure or your OCD forces you to do that.&lt;/li&gt;
  &lt;li&gt;For the pulling/pushing/merging activities, I recommand &lt;a href=&quot;https://desktop.github.com/&quot;&gt;Github Desktop&lt;/a&gt; or &lt;a href=&quot;https://github.atom.io/&quot;&gt;Atom-Github package&lt;/a&gt;. These Git GUIs are USUALLY better than the cmd lines especially when you have branched your repository or you want to merge branches.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;jekyll-what-i-need-is-just-markdown&quot;&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;: …what I need is just Markdown!&lt;/h2&gt;

&lt;p&gt;Still, a step-by-step tutorial from official website: &lt;a href=&quot;https://jekyllrb.com/docs/step-by-step/01-setup/&quot;&gt;Tutorial&lt;/a&gt;.&lt;br /&gt;
And a youtube tutorial: &lt;a href=&quot;https://youtu.be/fqFjuX4VZmU&quot;&gt;Tutorial2&lt;/a&gt;.&lt;br /&gt;
The default jekyll folder created by &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new &amp;lt;whereever&amp;gt;&lt;/code&gt; has a documented but complex structure. What I recommand is to use &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new --blank &amp;lt;whereever&amp;gt;&lt;/code&gt; and this will initilise a blank jekyll project. In &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;, specify &lt;code class=&quot;highlighter-rouge&quot;&gt;theme: minima&lt;/code&gt; to use the Jekyll default (neat) CSS style.&lt;br /&gt;
What I have created is just a simple default-style Jekyll repository. There are also &lt;code class=&quot;highlighter-rouge&quot;&gt;_include&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;_layout&lt;/code&gt; that can change the header, footer and even CSS/Javascript, there is also a bug displaying ‘HOME’ on the homepage which has not been fixed yet (continuous learning confirmed).&lt;/p&gt;

&lt;h2 id=&quot;retro-future-plan&quot;&gt;Retro: future plan&lt;/h2&gt;

&lt;p&gt;It is awesome to learn a new way of blogging &amp;amp; hosting the personal webpage, and of cource, it is a good habit for programmers to update their blogs in a period of time. I will try to write down 4-5 blogs per month in both English &amp;amp; Chinese (even in simple German for practice), this is really practical to improve my English writing &amp;amp; programming skills. The topics will cover CompSci(mostly), English writing &amp;amp; German studying experience(sometimes) and some daily blogs(rarely). I would be happy if someone comments or criticises my blogs (I promise this function will be deployed xd).&lt;/p&gt;

&lt;h6 id=&quot;el15ande-st-andrews&quot;&gt;&lt;em&gt;El15ande, St Andrews&lt;/em&gt;&lt;/h6&gt;
&lt;hr /&gt;

&lt;h6 id=&quot;关键词-网站部署--githubpage--jekyll&quot;&gt;&lt;em&gt;关键词: 网站部署 / GithubPage / Jekyll&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;intro-如果我想写博客&quot;&gt;Intro: 如果我想写博客…&lt;/h2&gt;

&lt;p&gt;这篇博客是我的GithubPage改版后的第一篇博客. 借助Jekyll, 我只需要写一些Markdown, 这些文字就可以自动转变成静态网页并经由GithubPage的服务器进行维护. 能够记录下自己的学习过程和创意, 不论对于程序员还是非程序员来说都是一个不断进步的过程, 使用这两样工具, 我们可以及时且省力的发布BLOG而不必让自己的点子白白溜走.&lt;br /&gt;
这篇BLOG将分享一些我在开发过程中学习到的经验及反思.&lt;/p&gt;

&lt;h2 id=&quot;githubpage-薅github的羊毛&quot;&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;GithubPage&lt;/a&gt;: 薅Github的羊毛&lt;/h2&gt;

&lt;p&gt;GithubPage注册中文教程 (来源CSDN): &lt;a href=&quot;https://blog.csdn.net/baidu_25464429/article/details/80805237&quot;&gt;链接&lt;/a&gt;&lt;br /&gt;
Git命令行CheatSheet (来源Github): &lt;a href=&quot;https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf&quot;&gt;链接&lt;/a&gt;&lt;br /&gt;
GithubPage最大的优势就是免费且安全, 但同时也要求使用者有基本的Git相关知识. 我个人推荐使用&lt;a href=&quot;https://desktop.github.com/&quot;&gt;Github Desktop&lt;/a&gt;或者&lt;a href=&quot;https://github.atom.io/&quot;&gt;Atom-Github package&lt;/a&gt;, 这些Apps有简洁的GUI, 不需要记住冗长的命令也可以自由的操纵Git.&lt;br /&gt;
新手可能会遇到的另一个问题是分支 (branching), 个人推荐除非OCD晚期, 否则&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;足够Jekyll使用.&lt;/p&gt;

&lt;h2 id=&quot;jekyll-我只需要写点markdown&quot;&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;: …我只需要写点Markdown&lt;/h2&gt;

&lt;p&gt;GithubPage注册中文教程 (来源CSDN): &lt;a href=&quot;https://blog.csdn.net/uselym/article/details/73608638&quot;&gt;链接&lt;/a&gt;&lt;br /&gt;
Jekyll是基于Ruby语言开发的静态网页生成器, 使用者需要先安装Ruby语言包,再使用&lt;code class=&quot;highlighter-rouge&quot;&gt;bundler&lt;/code&gt;安装. 默认配置下的Jekyll文件有详尽的文档注释但同时结构也非常复杂, 我使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new --blank .&lt;/code&gt;创建一个空白项目, 再创建&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;, 设置&lt;code class=&quot;highlighter-rouge&quot;&gt;theme: minima&lt;/code&gt;从而使用Jekyll默认提供的CSS风格.&lt;br /&gt;
由于没有&lt;code class=&quot;highlighter-rouge&quot;&gt;_layout&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;_include&lt;/code&gt;配置, 整个网页还存在着一些不足和bug, “&lt;strong&gt;将在近期修复xd&lt;/strong&gt;”&lt;/p&gt;

&lt;h2 id=&quot;retro-未来的计划&quot;&gt;Retro: 未来的计划&lt;/h2&gt;

&lt;p&gt;现在我的计划是一个月记录4-5篇BLOG, 主题包括开发经历, 英语写作及德语学习经历, 可能会试着用双语写作. 更多功能”&lt;strong&gt;即将上线xd&lt;/strong&gt;”.&lt;/p&gt;

&lt;h6 id=&quot;el15ande-圣安德鲁斯&quot;&gt;&lt;em&gt;El15ande, 圣安德鲁斯&lt;/em&gt;&lt;/h6&gt;</content><author><name></name></author><summary type="html">Keyword: Web Project Deployment / GithubPage / Jekyll</summary></entry></feed>