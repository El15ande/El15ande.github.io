<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-07-29T11:06:10+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">El15ande (Allen Wang)</title><subtitle>Penultimate student @ University of St Andrews</subtitle><entry><title type="html">JavaScript Variables Mysteries: Hoisting &amp;amp; Temporal Dead Zone</title><link href="http://localhost:4000/JS-Variable-Mysteries/" rel="alternate" type="text/html" title="JavaScript Variables Mysteries: Hoisting &amp; Temporal Dead Zone" /><published>2019-07-24T00:00:00+08:00</published><updated>2019-07-24T00:00:00+08:00</updated><id>http://localhost:4000/JS-Variable-Mysteries</id><content type="html" xml:base="http://localhost:4000/JS-Variable-Mysteries/">&lt;hr /&gt;

&lt;h6 id=&quot;keyword-es6-javascript-hoisting-temporal-dead-zone&quot;&gt;&lt;em&gt;Keyword: ES6, JavaScript Hoisting, Temporal Dead Zone&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;long-rest-since-my-last-blog&quot;&gt;Long rest since my last blog&lt;/h2&gt;

&lt;p&gt;Recently I have worked on SaaS front-end issues (using JavaScript libraries/frameworks such as Bootstrap &amp;amp; Vue.js). After fixing a series of bugs caused by the ‘mysterious’ hoisting mechanism, I am confused with ‘What should we use when we declare different types of variables/functions?’ &amp;amp; ‘How should we avoid referencing &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;s?’ and I decide to take a research on these questions.&lt;br /&gt;
In this blog I would like to share how hoisting works in JavaScript &amp;amp; what are the proper ways to use &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;.&lt;/p&gt;

&lt;h2 id=&quot;javascript-variable-basis-easy--&quot;&gt;JavaScript variable basis (easy :) )&lt;/h2&gt;

&lt;p&gt;It has been 4 years since ES6 introduced the definition of block-scoped (&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;) &amp;amp; global/function-scoped (&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;) variables, though ES6 is &lt;a href=&quot;http://kangax.github.io/compat-table/es6/&quot;&gt;STILL not supported by some compilers &amp;amp; browsers&lt;/a&gt;, it is highly recommanded for JavaScript newbies to understand how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; properly and how their variables/functions are hoisted. In my opinion, using &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;s everywhere is absolutely correct (concerning unstable environments), but it is better to separate different types of constants/variables (or even functions) apart in order to &lt;a href=&quot;https://github.com/airbnb/javascript#variables--const-let-group&quot;&gt;improve code readability&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;As a simple reminder, there are 3 ways to declare Javascript variables:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;const foo = 'bar'&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;This declares an ‘immutable’ constant like &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; in C++ or &lt;code class=&quot;highlighter-rouge&quot;&gt;final&lt;/code&gt; in Java. In fact, the attributes of the &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; object can be reassigned:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     const x = { foo: 'bar' };
     x.foo = 'baz';
     console.log(x.foo); // -&amp;gt; baz
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;and the elements of the &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; array can be reassigned as well:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     const x = ['foo', 'bar'];
     x[1] = 'baz';
     console.log(x); // -&amp;gt; ['foo', 'baz']
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var foo = 'bar'&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;The scope of &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; variable depends on &lt;u&gt;its current execution context&lt;/u&gt;, which is function-scoped:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     funciton f() {
         var foo = 'bar';
         console.log(foo); // -&amp;gt; bar
     }
     console.log(foo); // -&amp;gt; Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;or global-scoped if it is declared outside any function. It is noticable that &lt;u&gt;assigning a value to an undeclared variable implicitly creates it as a global variable &lt;/u&gt;(&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#Description&quot;&gt;reference&lt;/a&gt;)_, so at least one of &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; should be used when declaraing a variable.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let foo = 'bar'&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;A &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variable is block-scoped, which limited itself in its defined block:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     function f() {
         // Function scope starts
         let foo = 'bar';
         console.log(foo); // -&amp;gt; bar
         if (1) { // If-statement scope starts
             let foo = 'baz';
             console.log(foo); // -&amp;gt; baz
         } // If-statement scope ends
         console.log(foo); // -&amp;gt; bar
     } // Function scope ends
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;it is also noticable that global &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variables will not create properties for &lt;code class=&quot;highlighter-rouge&quot;&gt;window&lt;/code&gt; object, while global &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; variables will.&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     var x = 1;
     let y = 2;
     console.log(window.x); // -&amp;gt; 1
     console.log(window.y); // -&amp;gt; undefined
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Hoisting: the conceptual definition of this semantic is: &lt;u&gt;variables &amp;amp; functions declarations are physically moved to the top of Javascript code&lt;/u&gt;, so&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     foo = 'bar'; // Initialisation
     console.log(foo); // -&amp;gt; bar
     ...
     var foo; // Declaration
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;works when you run the code, because it equals to:&lt;/p&gt;
    &lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;     var foo; // Declaration hoisted at the top
     ...
     foo = 'bar'; // Initialisation
     console.log(foo) // -&amp;gt; bar
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The hoisting mechanism confuses many people at first (including me and my friends when we studied it) as it does not follow the ‘declare-before-use’ rule in other languages. In fact, &lt;u&gt;JavaScript put all variables &amp;amp; function declarations into the memory at the compilation stage, but does not change the code sequence (initialisation sequence)&lt;/u&gt;, so using a variable before it is initialised is still invalid:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    console.log(foo); // -&amp;gt; undefined
    var foo; // Declaration hoisted at the top
    foo = 'bar' // Initialisation after it is used
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    var foo = 'bar';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;is an initilisation, so this will not be hoisted, as shown in the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    var x = 1; // Initialisation
    console.log(x + &quot;&amp;amp;&quot; + y) // -&amp;gt; 1&amp;amp;undefined
    var y = 2; // Initialisation that is not hoisted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reference:&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var&quot;&gt;MDN developer guide: var&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let&quot;&gt;MDN developer guide: let&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Glossary/Hoisting&quot;&gt;MDN developer guide: hoisting&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;temporal-dead-zone-still-ok--&quot;&gt;Temporal Dead Zone (still OK :| )&lt;/h2&gt;
&lt;p&gt;Consider the following code in the global scope:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    console.log(foo1); // -&amp;gt; undefined
    var foo1 = 'bar';

    foo2 = 'barr'
    console.log(foo2); // -&amp;gt; 'barr'
    var foo2;

    console.log(foo3); // Uncaught ReferenceError
    let foo3 = 'baz';

    console.log(foo4); // Uncaught ReferenceError
    let foo4;
    foo4 = 'bazz';
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can simply understand the code: &lt;code class=&quot;highlighter-rouge&quot;&gt;foo1&lt;/code&gt; is used before initialisation and thus it should be &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; at the moment it is used, while &lt;code class=&quot;highlighter-rouge&quot;&gt;foo2&lt;/code&gt; is a typical example of hoisting. &lt;code class=&quot;highlighter-rouge&quot;&gt;foo3&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;foo4&lt;/code&gt; are both used before initialisation, but they throw &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;, this indicates that _&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;_&lt;u&gt;variables are not initialised until their definition is evaluated&lt;/u&gt;. Furthermore, consider &lt;code class=&quot;highlighter-rouge&quot;&gt;foo5&lt;/code&gt; below:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    foo5 = 'foobar';
    console.log(foo5); // Uncaught ReferenceError
    let foo5;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;this indicates that _&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;_&lt;u&gt;variables are not hoisted&lt;/u&gt;. In fact, &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variables are in Temporal Dead Zone (TDZ) &lt;u&gt;from the start of the block until the initialisation is processed&lt;/u&gt;. Variables in TDZ will always throw &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt; as it is an uninitialised state, even using &lt;code class=&quot;highlighter-rouge&quot;&gt;typeof&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    if(true) { //TDZ starts
        // Using typeof on an undeclared variable results in undefined
        console.log(typeof x); // -&amp;gt; undefined

        ... // TDZ continues
        console.log(foo); // Uncaught ReferenceError

        // Using typeof on variables in TDZ results in UncaughtError
        console.log(typeof foo);// Uncaught ReferenceError
        
        let foo = 'bar'; // Varible initialised, TDZ ends
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Due to the existance of TDZ, variables used before initialisation are going to throw &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;s, this motivates new JavaScript programmers to follow the ‘declare-initialise-use’ flow to create &amp;amp; use variables (which produces more modular &amp;amp; cleaner code).&lt;/p&gt;

&lt;p&gt;I would highly recommand new JavaScript programmers to type these codes in editors in order to understand how to use &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; properly, and stop here to grab a cup of coffee because the rest contents will focus on JavaScript lexical environment. However if you are curious about the mechanism of &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;, or you have been working on JavaScript for a long time, please proceed.&lt;/p&gt;

&lt;p&gt;Reference:&lt;br /&gt;
&lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let#Temporal_dead_zone&quot;&gt;MDN developer guide: TDZ&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;tdz-towards-hoisting-a-bit-hard--&quot;&gt;TDZ towards hoisting (a bit hard :( )&lt;/h2&gt;

&lt;p&gt;Starting from TDZ, the statement of &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variables do not hoist is acutally an over-simplified summary: &lt;u&gt;these variables hoist but throw errors when used before initialised, rather than return &lt;/u&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;_, consider the following code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    let x = 'foo';
    if(true) {
        console.log(x); // Uncaught ReferenceError
        let x = 'foobar';
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;On execution, &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; inside the block is hoisted as the first statement in the block, this produces TDZ and the console statement in TDZ generates &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt; which seems reasonable. As ES6 standard explained in &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-let-and-const-declarations&quot;&gt;13.3.1&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt; declarations define variables that are scoped to &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-execution-contexts&quot;&gt;the running execution context&lt;/a&gt;’s &lt;a href=&quot;http://www.ecma-international.org/ecma-262/6.0/#sec-execution-contexts&quot;&gt;LexicalEnvironment&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;the &lt;code class=&quot;highlighter-rouge&quot;&gt;LexicalEnvironment&lt;/code&gt; represents the scope which the variables exist.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;The variables are created when their containing Lexical Environment is instantiated but may not be accessed in any way until the variable’s LexicalBinding is evaluated.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This proves that &lt;code class=&quot;highlighter-rouge&quot;&gt;const/let&lt;/code&gt; variables do hoist at the moment of their scope is created, and the duration from the initialisation of the environment to the evaluation of variables is the TDZ (referenced as ‘may not accessed in any way’).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A variable defined by a LexicalBinding with an Initializer is assigned the value of its Initializer’s AssignmentExpression when the LexicalBinding is evaluated, not when the variable is created.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If a LexicalBinding in a &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; declaration does not have an Initializer the variable is assigned the value &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; when the LexicalBinding is evaluated.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;These declarations are not related to TDZ but referencing the basic properties of JavaScript variables: if a variable is assigned a value, the value will be usable only after the assignment (not after created, like &lt;code class=&quot;highlighter-rouge&quot;&gt;foo1&lt;/code&gt; or &lt;code class=&quot;highlighter-rouge&quot;&gt;foo3&lt;/code&gt; above), if a variable is not assigned any values, the default value will be &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; (after exiting TDZ, the variables work in the same way):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    if(true) {
        // TDZ
        let x; // TDZ ends
        // The above equals to `let x = undefined`

        console.log(x); // -&amp;gt; undefined
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Reference:&lt;br /&gt;
&lt;a href=&quot;http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified&quot;&gt;JS Rocks blog: TDZ demystified&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://segmentfault.com/a/1190000008213835&quot;&gt;Segmentfault blog: understanding ES6 TDZ (Chinese)&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;function-tdz-default-parameters-harder--&quot;&gt;Function TDZ: default parameters (harder &amp;gt;:( )&lt;/h2&gt;

&lt;p&gt;TDZ mechanism appears in a lot of scenarios, one application is the default parameters of a function. Consider this function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    function add(x = y, y = 0) {
        return x+y;
    }

    add(1,2) // -&amp;gt; 3

    //This equals to add(1, undefined)
    add(1) // -&amp;gt; 1

    add(undefined, 1) // Uncaught ReferenceError
    add() // Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default parameters &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; are evaluated from left to right at the running stage, so &lt;code class=&quot;highlighter-rouge&quot;&gt;y&lt;/code&gt; is in TDZ when &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt; is evaluated which causes a &lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;. Please be aware that TDZ violations will not be reported by the compiler, but it will throw the error when &lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt; is passed to &lt;code class=&quot;highlighter-rouge&quot;&gt;x&lt;/code&gt;, the similar scenatio is the IIFE version of this function:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    (function(x = y, y = 0) {
        return x+y;
    }(1,2)); // -&amp;gt; 3

    (function(x = y, y = 0) {
        return x+y;
    }(undefined, 1)); // Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Furthermore, the &lt;code class=&quot;highlighter-rouge&quot;&gt;let x = x&lt;/code&gt; situation also causes the TDZ violation:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    function cube(x = x) {
        return x*x*x;
    }

    cube(2); // -&amp;gt; 8
    cube(); // Uncaught ReferenceError

    //...or the IIFE version
    (function(x = x) {
        return x*x*x;
    }(2)) // -&amp;gt; 8

    (function(x = x) {
        return x*x*x;
    }()) // -&amp;gt; Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An interesting scenario is, what if the default parameter is given at the outside of the scope by the &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; variable? The answer is that it also causes the TDZ violation as &lt;u&gt;default parameters are evaluated in an intermediate scope&lt;/u&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Javascript&quot;&gt;    let foo = 42;

    (function(x = foo, foo) {
        return x+foo;
    }(1,2)); // -&amp;gt; 3

    (function(x = foo, foo) {
        //foo is undefined is this scope;
        return x+foo;
    }(1)); // -&amp;gt; NaN

    (function(x = foo, foo) {
        return x+foo;
    }()); // Uncaught ReferenceError
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In conclusion, I suggest &lt;u&gt;not to bind variables as the default parameters&lt;/u&gt; and &lt;u&gt;be careful of the variable scope where TDZ might exist&lt;/u&gt;. Also, Javascript classes (&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;) will also produce TDZ, if you are interested in this topic, please proceed to &lt;a href=&quot;http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified&quot;&gt;this article&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;introspection-ah-finally&quot;&gt;Introspection (ah finally)&lt;/h2&gt;

&lt;p&gt;The variables scopes &amp;amp; TDZ mechanism can be both helpful (providing error feedback when mixing scope) and dangerous (in cases of running stage errors), this enforces us to declare the global variables and scopes with more considerations and awareness. I was mixing &lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;s and &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;s before I totally understand the scopes in JavaScript, and I would like to be more considerate of the scopes in order to write more modular and cleaner code.&lt;/p&gt;

&lt;p&gt;This is a simplified translation of the Chinese version below, if you have any suggestions, questions or found any bugs/grammar mistakes about this blog, please email me and I am happy to answer (or fix this blog :) )&lt;/p&gt;

&lt;p&gt;Suggested further readings:&lt;br /&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/28140450&quot;&gt;Zhihu: understand &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt; in 2 months (Chinese)&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://dmitrysoshnikov.com/ecmascript/es6-notes-default-values-of-parameters&quot;&gt;Note 6. ES6: default values of parameters&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://dmitripavlutin.com/variables-lifecycle-and-why-let-is-not-hoisted/&quot;&gt;JavaScript variable lifecycle: why let is not hoisted&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;关键词-es6-javascript变量提升-暂存死区tdz&quot;&gt;&lt;em&gt;关键词: ES6, JavaScript变量提升, 暂存死区(TDZ)&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;重启博客&quot;&gt;重启博客…&lt;/h2&gt;

&lt;p&gt;由于最近的工作接触了一些SaaS前端的问题(主要是JS和框架的开发和bug修复), 在修复了一些由于变量提升(hoisting)和变量域(scope)的bug之后, 我对JS中&lt;code class=&quot;highlighter-rouge&quot;&gt;var&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;let&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;const&lt;/code&gt;的使用产生了疑惑: 如何确定变量的作用域? / 应该如何使用变量以确保最模块化(modular)的JS代码? / 如何最大限度的避免&lt;code class=&quot;highlighter-rouge&quot;&gt;ReferenceError&lt;/code&gt;和引用&lt;code class=&quot;highlighter-rouge&quot;&gt;undefined&lt;/code&gt;? 以下的内容中将分享一些我对于JS变量的理解.&lt;/p&gt;

&lt;h2 id=&quot;js常量变量基础&quot;&gt;JS常量变量基础&lt;/h2&gt;

&lt;h2 id=&quot;暂存死区-tdz&quot;&gt;暂存死区 (TDZ)&lt;/h2&gt;

&lt;h2 id=&quot;tdz与hoisting&quot;&gt;TDZ与Hoisting&lt;/h2&gt;

&lt;h2 id=&quot;函数tdz-默认参数&quot;&gt;函数TDZ: 默认参数&lt;/h2&gt;

&lt;h2 id=&quot;反思与总结&quot;&gt;反思与总结&lt;/h2&gt;</content><author><name></name></author><summary type="html">Keyword: ES6, JavaScript Hoisting, Temporal Dead Zone</summary></entry><entry><title type="html">Software Engineering In A Nutshell: FAQ &amp;amp; Answers From Ian Sommerville</title><link href="http://localhost:4000/Software-Engineering-FAQ/" rel="alternate" type="text/html" title="Software Engineering In A Nutshell: FAQ &amp; Answers From Ian Sommerville" /><published>2019-04-09T00:00:00+08:00</published><updated>2019-04-09T00:00:00+08:00</updated><id>http://localhost:4000/Software-Engineering-FAQ</id><content type="html" xml:base="http://localhost:4000/Software-Engineering-FAQ/">&lt;hr /&gt;

&lt;h6 id=&quot;keyword-software-engineering&quot;&gt;&lt;em&gt;Keyword: Software Engineering&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;well-he-was-a-st-andrews-processor&quot;&gt;Well, he was a St Andrews processor…&lt;/h2&gt;

&lt;p&gt;I am reading ‘Software Engineering’ by Ian Sommerville, his ‘FAQs about software engineering’ table on page 20 (in my opinion) is the most elegant and enlightened summary about software engineering. In the post I will share an adapted summary of the table.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Question&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Answer&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What is software?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;u&gt;Computer programs &amp;amp; associated documentation&lt;/u&gt; for a particular customer or a general market&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the attributes of good software?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;u&gt;Deliver the required functionality &amp;amp; performance&lt;/u&gt; to the user &amp;amp; &lt;u&gt;be maintainable, dependable &amp;amp; usable&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What is SE?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;An engineering discipline &lt;u&gt;concerned with all aspects of software production&lt;u&gt; from initial conception to operation &amp;amp; maintenance&lt;/u&gt;&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the fundamental SE activities?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Software specification, development, validation &amp;amp; evolution&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What is the difference between SE &amp;amp; CS?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CS focuses on theory &amp;amp; fundamentals, while SE is concerned with &lt;u&gt;practicalities of developing &amp;amp; delivering good software&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What is the difference between SE &amp;amp; system engineering?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;System engineering is concerned with all aspects of computer-based system development (including hardware, software &amp;amp; process engineering), while SE is part of it&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the key challenges facing SE?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Coping with &lt;u&gt;increasing diversity&lt;/u&gt;, demands for &lt;u&gt;reduced delivery times&lt;/u&gt; &amp;amp; &lt;u&gt;developing trustworthy software&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the costs of SE?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Roughly 60% are development costs, 40% are testing costs (custom software has higher evolution costs)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What are the best SE techniques &amp;amp; methods?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;u&gt;Different techniques are appropriate for different types of system&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;What differences has the Internet made to SE?&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Internet led to the development of massive, highly distributed, &lt;u&gt;service-based systems&lt;/u&gt; &amp;amp; supported the creation of an &lt;u&gt;'app' industry&lt;/u&gt; for mobile devices&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Reference: Ian Sommerville. 2015. Software Engineering (10th ed.). Pearson.&lt;/p&gt;

&lt;h6 id=&quot;el15ande-st-andrews&quot;&gt;&lt;em&gt;El15ande, St Andrews&lt;/em&gt;&lt;/h6&gt;
&lt;hr /&gt;

&lt;h6 id=&quot;关键词-软件工程&quot;&gt;&lt;em&gt;关键词: 软件工程&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;这本书的作者曾是我们学校的教授&quot;&gt;这本书的作者曾是我们学校的教授…&lt;/h2&gt;

&lt;p&gt;在阅读Ian Sommerville的著作《Software Engineering》一书时看到了他所汇总的‘软件工程FAQ’表格，我个人认为他对这些问题的回答十分精简和引人深思。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;问&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;答&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;如何定义‘软件’？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;面向特定顾客或市场的程序及其文档&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;优秀软件的特性？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;为用户提供必需的功能及性能 &amp;amp; 保持可维护性，可信度以及可使用性&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;如何定义‘软件工程’？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;解决软件开发及使用过程中各个方面问题的工程学&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;最基本的‘软件工程’行为有哪些？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;软件的 &lt;u&gt;需求说明，研发，检验 和 持续完善&lt;/u&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘软件工程’和‘计算机科学’的区别是什么？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;CS注重科学上的理论基础（深有体会），SE则注重开发及提供优秀软件的实践过程&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘软件工程’和‘系统工程’的区别是什么？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘系统工程’注重整个计算机（硬件，软件，应用的实际运行）系统的设计，SE包含在‘系统工程’中&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘软件工程’领域最大的挑战是什么？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;考虑递增的软件多样性和递减的开发时间，并开发可靠的软件&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;‘软件工程’花销占比如何分配？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;60%的开发花销 - 40%的测试花销（测试大过天）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;目前最好的‘软件工程’技术是什么？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;因系统而异，不同的技术对应不同的系统&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;互联网对于‘软件工程’的改变有哪些？&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1. 互联网引发了对于&lt;u&gt;面向服务的系统研发&lt;/u&gt;的热潮（分布式系统）/ 2.互联网为&lt;u&gt;移动应用研发业&lt;/u&gt;提供了基础（移动设备系统）&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;书籍：Ian Sommerville. 2015. Software Engineering (10th ed.). Pearson.&lt;/p&gt;

&lt;h6 id=&quot;el15ande-圣安德鲁斯&quot;&gt;&lt;em&gt;El15ande, 圣安德鲁斯&lt;/em&gt;&lt;/h6&gt;</content><author><name></name></author><summary type="html">Keyword: Software Engineering</summary></entry><entry><title type="html">Hello Jekyll: Build Personal Webpage With GithubPage &amp;amp; Jekyll</title><link href="http://localhost:4000/Hello-Jekyll/" rel="alternate" type="text/html" title="Hello Jekyll: Build Personal Webpage With GithubPage &amp; Jekyll" /><published>2019-02-11T00:00:00+08:00</published><updated>2019-02-11T00:00:00+08:00</updated><id>http://localhost:4000/Hello-Jekyll</id><content type="html" xml:base="http://localhost:4000/Hello-Jekyll/">&lt;hr /&gt;

&lt;h6 id=&quot;keyword-web-project-deployment--githubpage--jekyll&quot;&gt;&lt;em&gt;Keyword: Web Project Deployment / GithubPage / Jekyll&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;intro-when-i-really-want-to-write-some-blogs&quot;&gt;Intro: when I really want to write some blogs…&lt;/h2&gt;

&lt;p&gt;This is my first CompSci blog &amp;amp; what I have done is just writing some markdown like taking notes on a piece of paper, the whole website is generated by Jekyll &amp;amp; hosted by GithubPage. This is really convenient for programmers (or even non-programmers) to write down their ideas, experiences (or bug complaints) in a few words, then a webpage blog, decorated with nice CSS &amp;amp; clustered in ideal structure, is already there.&lt;br /&gt;
In this blog, I will share my experience about how to build a simple blogging website, with or without programming experience &amp;amp; totally without any money costs.&lt;/p&gt;

&lt;h2 id=&quot;githubpage-free-probably-website-hosting&quot;&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;GithubPage&lt;/a&gt;: free (probably) website hosting&lt;/h2&gt;

&lt;p&gt;There is a step-by-step tutorial from youtube for non-programmers: &lt;a href=&quot;https://youtu.be/FiOgz3nKpgk&quot;&gt;Tutorial&lt;/a&gt;.&lt;br /&gt;
And the Git command cheatsheet from Github: &lt;a href=&quot;https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf&quot;&gt;Cheatsheet&lt;/a&gt;.&lt;br /&gt;
A few tips:&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;The branching of the repoistory is actually not that necessary to do unless you want a really clustered repository structure or your OCD forces you to do that.&lt;/li&gt;
  &lt;li&gt;For the pulling/pushing/merging activities, I recommand &lt;a href=&quot;https://desktop.github.com/&quot;&gt;Github Desktop&lt;/a&gt; or &lt;a href=&quot;https://github.atom.io/&quot;&gt;Atom-Github package&lt;/a&gt;. These Git GUIs are USUALLY better than the cmd lines especially when you have branched your repository or you want to merge branches.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;jekyll-what-i-need-is-just-markdown&quot;&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;: …what I need is just Markdown!&lt;/h2&gt;

&lt;p&gt;Still, a step-by-step tutorial from official website: &lt;a href=&quot;https://jekyllrb.com/docs/step-by-step/01-setup/&quot;&gt;Tutorial&lt;/a&gt;.&lt;br /&gt;
And a youtube tutorial: &lt;a href=&quot;https://youtu.be/fqFjuX4VZmU&quot;&gt;Tutorial2&lt;/a&gt;.&lt;br /&gt;
The default jekyll folder created by &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new &amp;lt;whereever&amp;gt;&lt;/code&gt; has a documented but complex structure. What I recommand is to use &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new --blank &amp;lt;whereever&amp;gt;&lt;/code&gt; and this will initilise a blank jekyll project. In &lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;, specify &lt;code class=&quot;highlighter-rouge&quot;&gt;theme: minima&lt;/code&gt; to use the Jekyll default (neat) CSS style.&lt;br /&gt;
What I have created is just a simple default-style Jekyll repository. There are also &lt;code class=&quot;highlighter-rouge&quot;&gt;_include&lt;/code&gt; &amp;amp; &lt;code class=&quot;highlighter-rouge&quot;&gt;_layout&lt;/code&gt; that can change the header, footer and even CSS/Javascript, there is also a bug displaying ‘HOME’ on the homepage which has not been fixed yet (continuous learning confirmed).&lt;/p&gt;

&lt;h2 id=&quot;retro-future-plan&quot;&gt;Retro: future plan&lt;/h2&gt;

&lt;p&gt;It is awesome to learn a new way of blogging &amp;amp; hosting the personal webpage, and of cource, it is a good habit for programmers to update their blogs in a period of time. I will try to write down 4-5 blogs per month in both English &amp;amp; Chinese (even in simple German for practice), this is really practical to improve my English writing &amp;amp; programming skills. The topics will cover CompSci(mostly), English writing &amp;amp; German studying experience(sometimes) and some daily blogs(rarely). I would be happy if someone comments or criticises my blogs (I promise this function will be deployed xd).&lt;/p&gt;

&lt;h6 id=&quot;el15ande-st-andrews&quot;&gt;&lt;em&gt;El15ande, St Andrews&lt;/em&gt;&lt;/h6&gt;
&lt;hr /&gt;

&lt;h6 id=&quot;关键词-网站部署--githubpage--jekyll&quot;&gt;&lt;em&gt;关键词: 网站部署 / GithubPage / Jekyll&lt;/em&gt;&lt;/h6&gt;

&lt;h2 id=&quot;intro-如果我想写博客&quot;&gt;Intro: 如果我想写博客…&lt;/h2&gt;

&lt;p&gt;这篇博客是我的GithubPage改版后的第一篇博客. 借助Jekyll, 我只需要写一些Markdown, 这些文字就可以自动转变成静态网页并经由GithubPage的服务器进行维护. 能够记录下自己的学习过程和创意, 不论对于程序员还是非程序员来说都是一个不断进步的过程, 使用这两样工具, 我们可以及时且省力的发布BLOG而不必让自己的点子白白溜走.&lt;br /&gt;
这篇BLOG将分享一些我在开发过程中学习到的经验及反思.&lt;/p&gt;

&lt;h2 id=&quot;githubpage-薅github的羊毛&quot;&gt;&lt;a href=&quot;https://pages.github.com/&quot;&gt;GithubPage&lt;/a&gt;: 薅Github的羊毛&lt;/h2&gt;

&lt;p&gt;GithubPage注册中文教程 (来源CSDN): &lt;a href=&quot;https://blog.csdn.net/baidu_25464429/article/details/80805237&quot;&gt;链接&lt;/a&gt;&lt;br /&gt;
Git命令行CheatSheet (来源Github): &lt;a href=&quot;https://services.github.com/on-demand/downloads/github-git-cheat-sheet.pdf&quot;&gt;链接&lt;/a&gt;&lt;br /&gt;
GithubPage最大的优势就是免费且安全, 但同时也要求使用者有基本的Git相关知识. 我个人推荐使用&lt;a href=&quot;https://desktop.github.com/&quot;&gt;Github Desktop&lt;/a&gt;或者&lt;a href=&quot;https://github.atom.io/&quot;&gt;Atom-Github package&lt;/a&gt;, 这些Apps有简洁的GUI, 不需要记住冗长的命令也可以自由的操纵Git.&lt;br /&gt;
新手可能会遇到的另一个问题是分支 (branching), 个人推荐除非OCD晚期, 否则&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;足够Jekyll使用.&lt;/p&gt;

&lt;h2 id=&quot;jekyll-我只需要写点markdown&quot;&gt;&lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;: …我只需要写点Markdown&lt;/h2&gt;

&lt;p&gt;GithubPage注册中文教程 (来源CSDN): &lt;a href=&quot;https://blog.csdn.net/uselym/article/details/73608638&quot;&gt;链接&lt;/a&gt;&lt;br /&gt;
Jekyll是基于Ruby语言开发的静态网页生成器, 使用者需要先安装Ruby语言包,再使用&lt;code class=&quot;highlighter-rouge&quot;&gt;bundler&lt;/code&gt;安装. 默认配置下的Jekyll文件有详尽的文档注释但同时结构也非常复杂, 我使用的是&lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll new --blank .&lt;/code&gt;创建一个空白项目, 再创建&lt;code class=&quot;highlighter-rouge&quot;&gt;_config.yml&lt;/code&gt;, 设置&lt;code class=&quot;highlighter-rouge&quot;&gt;theme: minima&lt;/code&gt;从而使用Jekyll默认提供的CSS风格.&lt;br /&gt;
由于没有&lt;code class=&quot;highlighter-rouge&quot;&gt;_layout&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;_include&lt;/code&gt;配置, 整个网页还存在着一些不足和bug, “&lt;strong&gt;将在近期修复xd&lt;/strong&gt;”&lt;/p&gt;

&lt;h2 id=&quot;retro-未来的计划&quot;&gt;Retro: 未来的计划&lt;/h2&gt;

&lt;p&gt;现在我的计划是一个月记录4-5篇BLOG, 主题包括开发经历, 英语写作及德语学习经历, 可能会试着用双语写作. 更多功能”&lt;strong&gt;即将上线xd&lt;/strong&gt;”.&lt;/p&gt;

&lt;h6 id=&quot;el15ande-圣安德鲁斯&quot;&gt;&lt;em&gt;El15ande, 圣安德鲁斯&lt;/em&gt;&lt;/h6&gt;</content><author><name></name></author><summary type="html">Keyword: Web Project Deployment / GithubPage / Jekyll</summary></entry></feed>